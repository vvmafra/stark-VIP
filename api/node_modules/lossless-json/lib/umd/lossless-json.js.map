{"version":3,"file":"lossless-json.js","sources":["../esm/config.js","../esm/utils.js","../esm/LosslessNumber.js","../esm/numberParsers.js","../esm/revive.js","../esm/parse.js","../esm/reviveDate.js","../esm/stringify.js"],"sourcesContent":["/**\n * Get and/or set configuration options\n * @deprecated There is no config anymore\n */\nexport function config(_options) {\n  // Backward compatibility warning for v1.x\n  throw new Error('config is deprecated, support for circularRefs is removed from the library. ' + 'If you encounter circular references in your data structures, ' + 'please rethink your datastructures: ' + 'better prevent circular references in the first place.');\n}\n//# sourceMappingURL=config.js.map","/**\n * Test whether a string contains an integer number\n */\nexport function isInteger(value) {\n  return INTEGER_REGEX.test(value);\n}\nconst INTEGER_REGEX = /^-?[0-9]+$/;\n\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */\nexport function isNumber(value) {\n  return NUMBER_REGEX.test(value);\n}\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/;\n\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */\nexport function isSafeNumber(value, config) {\n  if (isInteger(value)) {\n    return Number.isSafeInteger(Number.parseInt(value, 10));\n  }\n  const num = Number.parseFloat(value);\n  const parsed = String(num);\n  if (value === parsed) {\n    return true;\n  }\n  const valueDigits = extractSignificantDigits(value);\n  const parsedDigits = extractSignificantDigits(parsed);\n  if (valueDigits === parsedDigits) {\n    return true;\n  }\n  if (config?.approx === true) {\n    // A value is approximately equal when:\n    // 1. it is a floating point number, not an integer\n    // 2. it has at least 14 digits\n    // 3. the first 14 digits are equal\n    const requiredDigits = 14;\n    if (!isInteger(value) && parsedDigits.length >= requiredDigits && valueDigits.startsWith(parsedDigits.substring(0, requiredDigits))) {\n      return true;\n    }\n  }\n  return false;\n}\nexport let UnsafeNumberReason = /*#__PURE__*/function (UnsafeNumberReason) {\n  UnsafeNumberReason[\"underflow\"] = \"underflow\";\n  UnsafeNumberReason[\"overflow\"] = \"overflow\";\n  UnsafeNumberReason[\"truncate_integer\"] = \"truncate_integer\";\n  UnsafeNumberReason[\"truncate_float\"] = \"truncate_float\";\n  return UnsafeNumberReason;\n}({});\n\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */\nexport function getUnsafeNumberReason(value) {\n  if (isSafeNumber(value, {\n    approx: false\n  })) {\n    return undefined;\n  }\n  if (isInteger(value)) {\n    return UnsafeNumberReason.truncate_integer;\n  }\n  const num = Number.parseFloat(value);\n  if (!Number.isFinite(num)) {\n    return UnsafeNumberReason.overflow;\n  }\n  if (num === 0) {\n    return UnsafeNumberReason.underflow;\n  }\n  return UnsafeNumberReason.truncate_float;\n}\n\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */\nexport function toSafeNumberOrThrow(value, config) {\n  const number = Number.parseFloat(value);\n  const unsafeReason = getUnsafeNumberReason(value);\n  if (config?.approx === true ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float : unsafeReason) {\n    const unsafeReasonText = unsafeReason?.replace(/_\\w+$/, '');\n    throw new Error(`Cannot safely convert to number: the value '${value}' would ${unsafeReasonText} and become ${number}`);\n  }\n  return number;\n}\n\n/**\n * Split a number into sign, digits, and exponent.\n * The value can be constructed again from a split number by inserting a dot\n * at the second character of the digits if there is more than one digit,\n * prepending it with the sign, and appending the exponent like `e${exponent}`\n */\nexport function splitNumber(value) {\n  const match = value.match(/^(-?)(\\d+\\.?\\d*)([eE]([+-]?\\d+))?$/);\n  if (!match) {\n    throw new SyntaxError(`Invalid number: ${value}`);\n  }\n  const sign = match[1];\n  const digitsStr = match[2];\n  let exponent = match[4] !== undefined ? Number.parseInt(match[4], 10) : 0;\n  const dot = digitsStr.indexOf('.');\n  exponent += dot !== -1 ? dot - 1 : digitsStr.length - 1;\n  const digits = digitsStr.replace('.', '') // remove the dot (must be removed before removing leading zeros)\n  .replace(/^0*/, zeros => {\n    // remove leading zeros, add their count to the exponent\n    exponent -= zeros.length;\n    return '';\n  }).replace(/0*$/, ''); // remove trailing zeros\n\n  return digits.length > 0 ? {\n    sign,\n    digits,\n    exponent\n  } : {\n    sign,\n    digits: '0',\n    exponent: exponent + 1\n  };\n}\n\n/**\n * Compare two strings containing a numeric value\n * Returns 1 when a is larger than b, 0 when they are equal,\n * and -1 when a is smaller than b.\n */\nexport function compareNumber(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  const aa = splitNumber(a);\n  const bb = splitNumber(b);\n  const sign = aa.sign === '-' ? -1 : 1;\n  if (aa.sign !== bb.sign) {\n    if (aa.digits === '0' && bb.digits === '0') {\n      return 0;\n    }\n    return sign;\n  }\n  if (aa.exponent !== bb.exponent) {\n    return aa.exponent > bb.exponent ? sign : aa.exponent < bb.exponent ? -sign : 0;\n  }\n  return aa.digits > bb.digits ? sign : aa.digits < bb.digits ? -sign : 0;\n}\n\n/**\n * Count the significant digits of a number.\n *\n * For example:\n *   '2.34' returns 3\n *   '-77' returns 2\n *   '0.003400' returns 2\n *   '120.5e+30' returns 4\n **/\nexport function countSignificantDigits(value) {\n  const {\n    start,\n    end\n  } = getSignificantDigitRange(value);\n  const dot = value.indexOf('.');\n  if (dot === -1 || dot < start || dot > end) {\n    return end - start;\n  }\n  return end - start - 1;\n}\n\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/\nexport function extractSignificantDigits(value) {\n  const {\n    start,\n    end\n  } = getSignificantDigitRange(value);\n  const digits = value.substring(start, end);\n  const dot = digits.indexOf('.');\n  if (dot === -1) {\n    return digits;\n  }\n  return digits.substring(0, dot) + digits.substring(dot + 1);\n}\n\n/**\n * Returns the range (start to end) of the significant digits of a value.\n * Note that this range _may_ contain the decimal dot.\n *\n * For example:\n *\n *     getSignificantDigitRange('0.0325900') // { start: 3, end: 7 }\n *     getSignificantDigitRange('2.0300')    // { start: 0, end: 3 }\n *     getSignificantDigitRange('0.0')       // { start: 3, end: 3 }\n *\n */\nfunction getSignificantDigitRange(value) {\n  let start = 0;\n  if (value[0] === '-') {\n    start++;\n  }\n  while (value[start] === '0' || value[start] === '.') {\n    start++;\n  }\n  let end = value.lastIndexOf('e');\n  if (end === -1) {\n    end = value.lastIndexOf('E');\n  }\n  if (end === -1) {\n    end = value.length;\n  }\n  while ((value[end - 1] === '0' || value[end - 1] === '.') && end > start) {\n    end--;\n  }\n  return {\n    start,\n    end\n  };\n}\n//# sourceMappingURL=utils.js.map","import { compareNumber, countSignificantDigits, getUnsafeNumberReason, isInteger, isNumber, UnsafeNumberReason } from './utils.js';\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nexport class LosslessNumber {\n  // numeric value as string\n\n  // type information\n  isLosslessNumber = true;\n  constructor(value) {\n    if (!isNumber(value)) {\n      throw new Error(`Invalid number (value: \"${value}\")`);\n    }\n    this.value = value;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  valueOf() {\n    const unsafeReason = getUnsafeNumberReason(this.value);\n\n    // safe or truncate_float\n    if (unsafeReason === undefined || unsafeReason === UnsafeNumberReason.truncate_float) {\n      return Number.parseFloat(this.value);\n    }\n\n    // truncate_integer\n    if (isInteger(this.value)) {\n      return BigInt(this.value);\n    }\n\n    // overflow or underflow\n    throw new Error(`Cannot safely convert to number: the value '${this.value}' would ${unsafeReason} and become ${Number.parseFloat(this.value)}`);\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   */\n  toString() {\n    return this.value;\n  }\n\n  // Note: we do NOT implement a .toJSON() method, and you should not implement\n  // or use that, it cannot safely turn the numeric value in the string into\n  // stringified JSON since it has to be parsed into a number first.\n}\n\n/**\n * Test whether a value is a LosslessNumber\n */\nexport function isLosslessNumber(value) {\n  // @ts-expect-error\n  return value && typeof value === 'object' && value.isLosslessNumber || false;\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nexport function toLosslessNumber(value) {\n  const maxDigits = 15;\n  if (countSignificantDigits(String(value)) > maxDigits) {\n    throw new Error(`Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself (value: ${value})`);\n  }\n  if (Number.isNaN(value)) {\n    throw new Error('Invalid number: NaN');\n  }\n  if (!Number.isFinite(value)) {\n    throw new Error(`Invalid number: ${value}`);\n  }\n  return new LosslessNumber(String(value));\n}\n\n/**\n * Compare two lossless numbers.\n * Returns 1 when a is larger than b, 0 when they are equal,\n * and -1 when a is smaller than b.\n */\nexport function compareLosslessNumber(a, b) {\n  return compareNumber(a.value, b.value);\n}\n//# sourceMappingURL=LosslessNumber.js.map","import { LosslessNumber } from './LosslessNumber.js';\nimport { isInteger } from './utils.js';\nexport function parseLosslessNumber(value) {\n  return new LosslessNumber(value);\n}\nexport function parseNumberAndBigInt(value) {\n  return isInteger(value) ? BigInt(value) : Number.parseFloat(value);\n}\n//# sourceMappingURL=numberParsers.js.map","import { isLosslessNumber } from './LosslessNumber.js';\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */\nexport function revive(json, reviver) {\n  return reviveValue({\n    '': json\n  }, '', json, reviver);\n}\n\n/**\n * Revive a value\n */\nfunction reviveValue(context, key, value, reviver) {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver));\n  }\n  if (value && typeof value === 'object' && !isLosslessNumber(value)) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value, reviver));\n  }\n  return reviver.call(context, key, value);\n}\n\n/**\n * Revive the properties of an object\n */\nfunction reviveObject(object, reviver) {\n  for (const key of Object.keys(object)) {\n    const value = reviveValue(object, key, object[key], reviver);\n    if (value !== undefined) {\n      object[key] = value;\n    } else {\n      delete object[key];\n    }\n  }\n  return object;\n}\n\n/**\n * Revive the properties of an Array\n */\nfunction reviveArray(array, reviver) {\n  for (let i = 0; i < array.length; i++) {\n    array[i] = reviveValue(array, String(i), array[i], reviver);\n  }\n  return array;\n}\n//# sourceMappingURL=revive.js.map","import { parseLosslessNumber } from './numberParsers.js';\nimport { revive } from './revive.js';\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [options=ParseOptions | NumberParserArgument]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse(text, reviver, options) {\n  const optionsObj = typeof options === 'function' ? {\n    parseNumber: options\n  } : options;\n  const parseNumber = optionsObj?.parseNumber ?? parseLosslessNumber;\n  const onDuplicateKey = optionsObj?.onDuplicateKey ?? throwDuplicateKey;\n  let i = 0;\n  const value = parseValue();\n  expectValue(value);\n  expectEndOfInput();\n  return reviver ? revive(value, reviver) : value;\n  function parseObject() {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++;\n      skipWhitespace();\n      const object = {};\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma();\n          skipWhitespace();\n        } else {\n          initial = false;\n        }\n        const start = i;\n        const key = parseString();\n        if (key === undefined) {\n          throwObjectKeyExpected();\n          return; // To make TS happy\n        }\n        skipWhitespace();\n        eatColon();\n        const value = parseValue();\n        if (value === undefined) {\n          throwObjectValueExpected();\n          return; // To make TS happy\n        }\n\n        // handle duplicate keys\n        // biome-ignore lint/suspicious/noPrototypeBuiltins: TODO: replace with hasOwn one day, when browser support is high enough\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          const returnedValue = onDuplicateKey({\n            key,\n            position: start + 1,\n            oldValue: object[key],\n            newValue: value\n          });\n          if (returnedValue !== undefined) {\n            object[key] = returnedValue;\n          }\n        } else {\n          object[key] = value;\n        }\n      }\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected();\n      }\n      i++;\n      return object;\n    }\n  }\n  function parseArray() {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++;\n      skipWhitespace();\n      const array = [];\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma();\n        } else {\n          initial = false;\n        }\n        const value = parseValue();\n        expectArrayItem(value);\n        array.push(value);\n      }\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected();\n      }\n      i++;\n      return array;\n    }\n  }\n  function parseValue() {\n    skipWhitespace();\n    const value = parseString() ?? parseNumeric() ?? parseObject() ?? parseArray() ?? parseKeyword('true', true) ?? parseKeyword('false', false) ?? parseKeyword('null', null);\n    skipWhitespace();\n    return value;\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length;\n      return value;\n    }\n  }\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++;\n    }\n  }\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++;\n      let result = '';\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          const char = text[i + 1];\n          const escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            result += escapeChar;\n            i++;\n          } else if (char === 'u') {\n            if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {\n              result += String.fromCharCode(Number.parseInt(text.slice(i + 2, i + 6), 16));\n              i += 5;\n            } else {\n              throwInvalidUnicodeCharacter(i);\n            }\n          } else {\n            throwInvalidEscapeCharacter(i);\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i];\n          } else {\n            throwInvalidCharacter(text[i]);\n          }\n        }\n        i++;\n      }\n      expectEndOfString();\n      i++;\n      return result;\n    }\n  }\n  function parseNumeric() {\n    const start = i;\n    if (text.charCodeAt(i) === codeMinus) {\n      i++;\n      expectDigit(start);\n    }\n    if (text.charCodeAt(i) === codeZero) {\n      i++;\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++;\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeDot) {\n      i++;\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++;\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++;\n      }\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (i > start) {\n      return parseNumber(text.slice(start, i));\n    }\n  }\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`);\n    }\n    i++;\n  }\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`);\n    }\n    i++;\n  }\n  function expectValue(value) {\n    if (value === undefined) {\n      throw new SyntaxError(`JSON value expected ${gotAt()}`);\n    }\n  }\n  function expectArrayItem(value) {\n    if (value === undefined) {\n      throw new SyntaxError(`Array item expected ${gotAt()}`);\n    }\n  }\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(`Expected end of input ${gotAt()}`);\n    }\n  }\n  function expectDigit(start) {\n    if (!isDigit(text.charCodeAt(i))) {\n      const numSoFar = text.slice(start, i);\n      throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`);\n    }\n  }\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(`End of string '\"' expected ${gotAt()}`);\n    }\n  }\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(`Quoted object key expected ${gotAt()}`);\n  }\n  function throwDuplicateKey(_ref) {\n    let {\n      key,\n      position\n    } = _ref;\n    throw new SyntaxError(`Duplicate key '${key}' encountered at position ${position}`);\n  }\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`);\n  }\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`);\n  }\n  function throwInvalidCharacter(char) {\n    throw new SyntaxError(`Invalid character '${char}' ${pos()}`);\n  }\n  function throwInvalidEscapeCharacter(start) {\n    const chars = text.slice(start, start + 2);\n    throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`);\n  }\n  function throwObjectValueExpected() {\n    throw new SyntaxError(`Object value expected after ':' ${pos()}`);\n  }\n  function throwInvalidUnicodeCharacter(start) {\n    const chars = text.slice(start, start + 6);\n    throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`);\n  }\n\n  // zero based character position\n  function pos() {\n    return `at position ${i}`;\n  }\n  function got() {\n    return i < text.length ? `but got '${text[i]}'` : 'but reached end of input';\n  }\n  function gotAt() {\n    return `${got()} ${pos()}`;\n  }\n}\nfunction isWhitespace(code) {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\nfunction isHex(code) {\n  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;\n}\nfunction isDigit(code) {\n  return code >= codeZero && code <= codeNine;\n}\nfunction isNonZeroDigit(code) {\n  return code >= codeOne && code <= codeNine;\n}\nexport function isValidStringCharacter(code) {\n  return code >= 0x20 && code <= 0x10ffff;\n}\nexport function isDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]));\n  }\n  if (isObject(a) && isObject(b)) {\n    const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])];\n    return keys.every(key => isDeepEqual(a[key], b[key]));\n  }\n  return false;\n}\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null;\n}\n\n// map with all escape characters\nconst escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\nconst codeBackslash = 0x5c; // \"\\\"\nconst codeOpeningBrace = 0x7b; // \"{\"\nconst codeClosingBrace = 0x7d; // \"}\"\nconst codeOpeningBracket = 0x5b; // \"[\"\nconst codeClosingBracket = 0x5d; // \"]\"\nconst codeSpace = 0x20; // \" \"\nconst codeNewline = 0xa; // \"\\n\"\nconst codeTab = 0x9; // \"\\t\"\nconst codeReturn = 0xd; // \"\\r\"\nconst codeDoubleQuote = 0x0022; // \"\nconst codePlus = 0x2b; // \"+\"\nconst codeMinus = 0x2d; // \"-\"\nconst codeZero = 0x30;\nconst codeOne = 0x31;\nconst codeNine = 0x39;\nconst codeComma = 0x2c; // \",\"\nconst codeDot = 0x2e; // \".\" (dot, period)\nconst codeColon = 0x3a; // \":\"\nexport const codeUppercaseA = 0x41; // \"A\"\nexport const codeLowercaseA = 0x61; // \"a\"\nexport const codeUppercaseE = 0x45; // \"E\"\nexport const codeLowercaseE = 0x65; // \"e\"\nexport const codeUppercaseF = 0x46; // \"F\"\nexport const codeLowercaseF = 0x66; // \"f\"\n//# sourceMappingURL=parse.js.map","/**\n * Revive a string containing an ISO 8601 date string into a JavaScript `Date` object\n */\nexport function reviveDate(_key, value) {\n  return typeof value === 'string' && isoDateRegex.test(value) ? new Date(value) : value;\n}\n\n// Matches strings like \"2022-08-25T09:39:19.288Z\"\nconst isoDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;\n//# sourceMappingURL=reviveDate.js.map","import { isNumber } from './utils.js';\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param value\n * The value to convert to a JSON string.\n *\n * @param [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @param [numberStringifiers]\n * An optional list with additional number stringifiers, for example to serialize\n * a BigNumber. The output of the function must be valid stringified JSON.\n * When `undefined` is returned, the property will be deleted from the object.\n * The difference with using a `replacer` is that the output of a `replacer`\n * must be JSON and will be stringified afterwards, whereas the output of the\n * `numberStringifiers` is already stringified JSON.\n *\n * @returns Returns the string representation of the JSON object.\n */\nexport function stringify(value, replacer, space, numberStringifiers) {\n  const resolvedSpace = resolveSpace(space);\n  const replacedValue = typeof replacer === 'function' ? replacer.call({\n    '': value\n  }, '', value) : value;\n  return stringifyValue(replacedValue, '');\n\n  /**\n   * Stringify a value\n   */\n  function stringifyValue(value, indent) {\n    if (Array.isArray(numberStringifiers)) {\n      const stringifier = numberStringifiers.find(item => item.test(value));\n      if (stringifier) {\n        const str = stringifier.stringify(value);\n        if (typeof str !== 'string' || !isNumber(str)) {\n          throw new Error(`Invalid JSON number: output of a number stringifier must be a string containing a JSON number (output: ${str})`);\n        }\n        return str;\n      }\n    }\n\n    // boolean, null, number, string, or date\n    if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || value === null || value instanceof Date || value instanceof Boolean || value instanceof Number || value instanceof String) {\n      return JSON.stringify(value);\n    }\n\n    // lossless number, the secret ingredient :)\n    // @ts-expect-error\n    if (value?.isLosslessNumber) {\n      return value.toString();\n    }\n\n    // BigInt\n    if (typeof value === 'bigint') {\n      return value.toString();\n    }\n\n    // Array\n    if (Array.isArray(value)) {\n      return stringifyArray(value, indent);\n    }\n\n    // Object (test lastly!)\n    if (value && typeof value === 'object') {\n      return stringifyObject(value, indent);\n    }\n    return undefined;\n  }\n\n  /**\n   * Stringify an array\n   */\n  function stringifyArray(array, indent) {\n    if (array.length === 0) {\n      return '[]';\n    }\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    let str = resolvedSpace ? '[\\n' : '[';\n    for (let i = 0; i < array.length; i++) {\n      const item = typeof replacer === 'function' ? replacer.call(array, String(i), array[i]) : array[i];\n      if (resolvedSpace) {\n        str += childIndent;\n      }\n      if (typeof item !== 'undefined' && typeof item !== 'function') {\n        str += stringifyValue(item, childIndent);\n      } else {\n        str += 'null';\n      }\n      if (i < array.length - 1) {\n        str += resolvedSpace ? ',\\n' : ',';\n      }\n    }\n    str += resolvedSpace ? `\\n${indent}]` : ']';\n    return str;\n  }\n\n  /**\n   * Stringify an object\n   */\n  function stringifyObject(object, indent) {\n    if (typeof object.toJSON === 'function') {\n      return stringify(object.toJSON(), replacer, space, undefined);\n    }\n    const keys = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object);\n    if (keys.length === 0) {\n      return '{}';\n    }\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    let first = true;\n    let str = resolvedSpace ? '{\\n' : '{';\n    for (const key of keys) {\n      const value = typeof replacer === 'function' ? replacer.call(object, key, object[key]) : object[key];\n      if (includeProperty(key, value)) {\n        if (first) {\n          first = false;\n        } else {\n          str += resolvedSpace ? ',\\n' : ',';\n        }\n        const keyStr = JSON.stringify(key);\n        str += resolvedSpace ? `${childIndent + keyStr}: ` : `${keyStr}:`;\n        str += stringifyValue(value, childIndent);\n      }\n    }\n    str += resolvedSpace ? `\\n${indent}}` : '}';\n    return str;\n  }\n\n  /**\n   * Test whether to include a property in a stringified object or not.\n   */\n  function includeProperty(_key, value) {\n    return typeof value !== 'undefined' && typeof value !== 'function' && typeof value !== 'symbol';\n  }\n}\n\n/**\n * Resolve a JSON stringify space:\n * replace a number with a string containing that number of spaces\n */\nfunction resolveSpace(space) {\n  if (typeof space === 'number') {\n    return ' '.repeat(space);\n  }\n  if (typeof space === 'string' && space !== '') {\n    return space;\n  }\n  return undefined;\n}\n//# sourceMappingURL=stringify.js.map"],"names":["g","f","exports","module","define","amd","globalThis","self","LosslessJSON","this","isInteger","value","INTEGER_REGEX","test","isNumber","NUMBER_REGEX","isSafeNumber","config","Number","isSafeInteger","parseInt","num","parseFloat","parsed","String","valueDigits","extractSignificantDigits","parsedDigits","approx","requiredDigits","length","startsWith","substring","UnsafeNumberReason","getUnsafeNumberReason","truncate_integer","isFinite","underflow","truncate_float","overflow","splitNumber","match","SyntaxError","sign","digitsStr","exponent","undefined","dot","indexOf","digits","replace","zeros","compareNumber","a","b","aa","bb","start","end","getSignificantDigitRange","lastIndexOf","LosslessNumber","isLosslessNumber","constructor","Error","valueOf","unsafeReason","BigInt","toString","parseLosslessNumber","reviveValue","context","key","reviver","Array","isArray","call","array","i","reviveArray","object","Object","keys","reviveObject","isHex","code","codeZero","codeNine","codeUppercaseA","codeUppercaseF","codeLowercaseA","codeLowercaseF","isDigit","isDeepEqual","every","item","index","isObject","Set","escapeCharacters","n","r","t","codeBackslash","codeOpeningBrace","codeClosingBrace","codeOpeningBracket","codeClosingBracket","codeSpace","codeNewline","codeTab","codeReturn","codeDoubleQuote","codePlus","codeMinus","codeOne","codeComma","codeDot","codeColon","codeUppercaseE","codeLowercaseE","isoDateRegex","compareLosslessNumber","_options","parse","text","options","optionsObj","parseNumber","onDuplicateKey","_ref","position","parseValue","gotAt","expectValue","expectEndOfInput","json","revive","parseObject","charCodeAt","skipWhitespace","initial","eatComma","parseString","throwObjectKeyExpected","eatColon","throwObjectValueExpected","prototype","hasOwnProperty","returnedValue","oldValue","newValue","throwObjectKeyOrEndExpected","parseArray","expectArrayItem","push","throwArrayItemOrEndExpected","expectDigit","slice","parseNumeric","parseKeyword","name","result","char","escapeChar","fromCharCode","throwInvalidUnicodeCharacter","throwInvalidEscapeCharacter","throwInvalidCharacter","expectEndOfString","numSoFar","pos","chars","parseNumberAndBigInt","reviveDate","_key","Date","stringify","replacer","space","numberStringifiers","resolvedSpace","repeat","resolveSpace","stringifyValue","indent","stringifier","find","str","Boolean","JSON","childIndent","stringifyArray","toJSON","map","first","includeProperty","keyStr","stringifyObject","toLosslessNumber","countSignificantDigits","isNaN","toSafeNumberOrThrow","number","unsafeReasonText"],"mappings":"CAAA,SAAAA,EAAAC,GAAA,iBAAAC,SAAA,oBAAAC,OAAAF,EAAAC,SAAA,mBAAAE,QAAAA,OAAAC,IAAAD,OAAA,CAAA,WAAAH,GAAAA,GAAAD,EAAA,oBAAAM,WAAAA,WAAAN,GAAAO,MAAAC,aAAA,CAAA,EAAA,CAAA,CAAAC,MAAA,SAAAP,GAAA,aCGO,SAASQ,EAAUC,GACxB,OAAOC,EAAcC,KAAKF,EAC5B,CACA,MAAMC,EAAgB,aAMf,SAASE,EAASH,GACvB,OAAOI,EAAaF,KAAKF,EAC3B,CACA,MAAMI,EAAe,gDAUd,SAASC,EAAaL,EAAOM,GAClC,GAAIP,EAAUC,GACZ,OAAOO,OAAOC,cAAcD,OAAOE,SAAST,EAAO,KAErD,MAAMU,EAAMH,OAAOI,WAAWX,GACxBY,EAASC,OAAOH,GACtB,GAAIV,IAAUY,EACZ,OAAO,EAET,MAAME,EAAcC,EAAyBf,GACvCgB,EAAeD,EAAyBH,GAC9C,GAAIE,IAAgBE,EAClB,OAAO,EAET,IAAuB,IAAnBV,GAAQW,OAAiB,CAK3B,MAAMC,EAAiB,GACvB,IAAKnB,EAAUC,IAAUgB,EAAaG,QAAUD,GAAkBJ,EAAYM,WAAWJ,EAAaK,UAAU,EAAGH,IACjH,OAAO,CAEX,CACA,OAAO,CACT,CACU,IAACI,EAAkC,SAAUA,GAKrD,OAJAA,EAA8B,UAAI,YAClCA,EAA6B,SAAI,WACjCA,EAAqC,iBAAI,mBACzCA,EAAmC,eAAI,iBAChCA,CACT,CAN6C,CAM3C,CAAA,GAOK,SAASC,EAAsBvB,GACpC,GAAIK,EAAaL,EAAO,CACtBiB,QAAQ,IAER,OAEF,GAAIlB,EAAUC,GACZ,OAAOsB,EAAmBE,iBAE5B,MAAMd,EAAMH,OAAOI,WAAWX,GAC9B,OAAKO,OAAOkB,SAASf,GAGT,IAARA,EACKY,EAAmBI,UAErBJ,EAAmBK,eALjBL,EAAmBM,QAM9B,CAsBO,SAASC,EAAY7B,GAC1B,MAAM8B,EAAQ9B,EAAM8B,MAAM,sCAC1B,IAAKA,EACH,MAAM,IAAIC,YAAY,mBAAmB/B,KAE3C,MAAMgC,EAAOF,EAAM,GACbG,EAAYH,EAAM,GACxB,IAAII,OAAwBC,IAAbL,EAAM,GAAmBvB,OAAOE,SAASqB,EAAM,GAAI,IAAM,EACxE,MAAMM,EAAMH,EAAUI,QAAQ,KAC9BH,QAAYE,EAAaA,EAAM,EAAIH,EAAUd,OAAS,EACtD,MAAMmB,EAASL,EAAUM,QAAQ,IAAK,IACrCA,QAAQ,OAAOC,IAEdN,GAAYM,EAAMrB,OACX,MACNoB,QAAQ,MAAO,IAElB,OAAOD,EAAOnB,OAAS,EAAI,CACzBa,OACAM,SACAJ,YACE,CACFF,OACAM,OAAQ,IACRJ,SAAUA,EAAW,EAEzB,CAOO,SAASO,EAAcC,EAAGC,GAC/B,GAAID,IAAMC,EACR,OAAO,EAET,MAAMC,EAAKf,EAAYa,GACjBG,EAAKhB,EAAYc,GACjBX,EAAmB,MAAZY,EAAGZ,MAAe,EAAK,EACpC,OAAIY,EAAGZ,OAASa,EAAGb,KACC,MAAdY,EAAGN,QAAgC,MAAdO,EAAGP,OACnB,EAEFN,EAELY,EAAGV,WAAaW,EAAGX,SACdU,EAAGV,SAAWW,EAAGX,SAAWF,EAAOY,EAAGV,SAAWW,EAAGX,UAAYF,EAAO,EAEzEY,EAAGN,OAASO,EAAGP,OAASN,EAAOY,EAAGN,OAASO,EAAGP,QAAUN,EAAO,CACxE,CAgCO,SAASjB,EAAyBf,GACvC,MAAM8C,MACJA,EAAKC,IACLA,GACEC,EAAyBhD,GACvBsC,EAAStC,EAAMqB,UAAUyB,EAAOC,GAChCX,EAAME,EAAOD,QAAQ,KAC3B,OAAY,IAARD,EACKE,EAEFA,EAAOjB,UAAU,EAAGe,GAAOE,EAAOjB,UAAUe,EAAM,EAC3D,CAaA,SAASY,EAAyBhD,GAChC,IAAI8C,EAAQ,EAIZ,IAHiB,MAAb9C,EAAM,IACR8C,IAEsB,MAAjB9C,EAAM8C,IAAmC,MAAjB9C,EAAM8C,IACnCA,IAEF,IAAIC,EAAM/C,EAAMiD,YAAY,KAO5B,KANY,IAARF,IACFA,EAAM/C,EAAMiD,YAAY,OAEd,IAARF,IACFA,EAAM/C,EAAMmB,SAEa,MAAnBnB,EAAM+C,EAAM,IAAiC,MAAnB/C,EAAM+C,EAAM,KAAeA,EAAMD,GACjEC,IAEF,MAAO,CACLD,QACAC,MAEJ,CClOO,MAAMG,EAIXC,kBAAmB,EACnB,WAAAC,CAAYpD,GACV,IAAKG,EAASH,GACZ,MAAM,IAAIqD,MAAM,2BAA2BrD,OAE7CF,KAAKE,MAAQA,CACf,CAaA,OAAAsD,GACE,MAAMC,EAAehC,EAAsBzB,KAAKE,OAGhD,QAAqBmC,IAAjBoB,GAA8BA,IAAiBjC,EAAmBK,eACpE,OAAOpB,OAAOI,WAAWb,KAAKE,OAIhC,GAAID,EAAUD,KAAKE,OACjB,OAAOwD,OAAO1D,KAAKE,OAIrB,MAAM,IAAIqD,MAAM,+CAA+CvD,KAAKE,gBAAgBuD,gBAA2BhD,OAAOI,WAAWb,KAAKE,SACxI,CAKA,QAAAyD,GACE,OAAO3D,KAAKE,KACd,EAUK,SAASmD,EAAiBnD,GAE/B,OAAOA,GAA0B,iBAAVA,GAAsBA,EAAMmD,mBAAoB,CACzE,CC7DO,SAASO,EAAoB1D,GAClC,OAAO,IAAIkD,EAAelD,EAC5B,CCgBA,SAAS2D,EAAYC,EAASC,EAAK7D,EAAO8D,GACxC,OAAIC,MAAMC,QAAQhE,GACT8D,EAAQG,KAAKL,EAASC,EA4BjC,SAAqBK,EAAOJ,GAC1B,IAAK,IAAIK,EAAI,EAAGA,EAAID,EAAM/C,OAAQgD,IAChCD,EAAMC,GAAKR,EAAYO,EAAOrD,OAAOsD,GAAID,EAAMC,GAAIL,GAErD,OAAOI,CACT,CAjCsCE,CAAYpE,EAAO8D,IAEnD9D,GAA0B,iBAAVA,IAAuBmD,EAAiBnD,GAGnD8D,EAAQG,KAAKL,EAASC,EAQjC,SAAsBQ,EAAQP,GAC5B,IAAK,MAAMD,KAAOS,OAAOC,KAAKF,GAAS,CACrC,MAAMrE,EAAQ2D,EAAYU,EAAQR,EAAKQ,EAAOR,GAAMC,QACtC3B,IAAVnC,EACFqE,EAAOR,GAAO7D,SAEPqE,EAAOR,EAElB,CACA,OAAOQ,CACT,CAlBsCG,CAAaxE,EAAO8D,IAEjDA,EAAQG,KAAKL,EAASC,EAAK7D,EACpC,CC0PA,SAASyE,EAAMC,GACb,OAAOA,GAAQC,GAAYD,GAAQE,GAAYF,GAAQG,GAAkBH,GAAQI,GAAkBJ,GAAQK,GAAkBL,GAAQM,CACvI,CACA,SAASC,EAAQP,GACf,OAAOA,GAAQC,GAAYD,GAAQE,CACrC,CAOO,SAASM,EAAYxC,EAAGC,GAC7B,GAAID,IAAMC,EACR,OAAO,EAET,GAAIoB,MAAMC,QAAQtB,IAAMqB,MAAMC,QAAQrB,GACpC,OAAOD,EAAEvB,SAAWwB,EAAExB,QAAUuB,EAAEyC,OAAM,CAACC,EAAMC,IAAUH,EAAYE,EAAMzC,EAAE0C,MAE/E,GAAIC,EAAS5C,IAAM4C,EAAS3C,GAAI,CAE9B,MADa,IAAI,IAAI4C,IAAI,IAAIjB,OAAOC,KAAK7B,MAAO4B,OAAOC,KAAK5B,MAChDwC,OAAMtB,GAAOqB,EAAYxC,EAAEmB,GAAMlB,EAAEkB,KACjD,CACA,OAAO,CACT,CACA,SAASyB,EAAStF,GAChB,MAAwB,iBAAVA,GAAgC,OAAVA,CACtC,CAGA,MAAMwF,EAAmB,CACvB,IAAK,IACL,KAAM,KACN,IAAK,IACL7C,EAAG,KACHrD,EAAG,KACHmG,EAAG,KACHC,EAAG,KACHC,EAAG,MAGCC,EAAgB,GAChBC,EAAmB,IACnBC,EAAmB,IACnBC,EAAqB,GACrBC,EAAqB,GACrBC,EAAY,GACZC,EAAc,GACdC,EAAU,EACVC,EAAa,GACbC,EAAkB,GAClBC,EAAW,GACXC,EAAY,GACZ5B,EAAW,GACX6B,EAAU,GACV5B,EAAW,GACX6B,EAAY,GACZC,EAAU,GACVC,EAAY,GACL9B,EAAiB,GACjBE,EAAiB,GACjB6B,EAAiB,GACjBC,EAAiB,IACjB/B,EAAiB,GACjBE,EAAiB,IChV9B,MAAM8B,EAAe,gDC4JrBvH,EAAA2D,eAAAA,EAAA3D,EAAA+B,mBAAAA,EAAA/B,EAAAwH,sBL5EO,SAA+BrE,EAAGC,GACvC,OAAOF,EAAcC,EAAE1C,MAAO2C,EAAE3C,MAClC,EK0EAT,EAAAkD,cAAAA,EAAAlD,EAAAe,OPhKO,SAAgB0G,GAErB,MAAM,IAAI3D,MAAM,uOAClB,EO6JA9D,EAAAgC,sBAAAA,EAAAhC,EAAAQ,UAAAA,EAAAR,EAAA4D,iBAAAA,EAAA5D,EAAAY,SAAAA,EAAAZ,EAAAc,aAAAA,EAAAd,EAAA0H,MF5IO,SAAeC,EAAMpD,EAASqD,GACnC,MAAMC,EAAgC,mBAAZD,EAAyB,CACjDE,YAAaF,GACXA,EACEE,EAAcD,GAAYC,aAAe3D,EACzC4D,EAAiBF,GAAYE,gBAiNnC,SAA2BC,GACzB,IAAI1D,IACFA,EAAG2D,SACHA,GACED,EACJ,MAAM,IAAIxF,YAAY,kBAAkB8B,8BAAgC2D,IAC1E,EAtNA,IAAIrD,EAAI,EACR,MAAMnE,EAAQyH,IAGd,OA+KA,SAAqBzH,GACnB,QAAcmC,IAAVnC,EACF,MAAM,IAAI+B,YAAY,uBAAuB2F,MAEjD,CArLAC,CAAY3H,GA2LZ,WACE,GAAImE,EAAI+C,EAAK/F,OACX,MAAM,IAAIY,YAAY,yBAAyB2F,MAEnD,CA9LAE,GACO9D,EDvBF,SAAgB+D,EAAM/D,GAC3B,OAAOH,EAAY,CACjB,GAAIkE,GACH,GAAIA,EAAM/D,EACf,CCmBmBgE,CAAO9H,EAAO8D,GAAW9D,EAC1C,SAAS+H,IACP,GAAIb,EAAKc,WAAW7D,KAAO0B,EAAkB,CAC3C1B,IACA8D,IACA,MAAM5D,EAAS,CAAA,EACf,IAAI6D,GAAU,EACd,KAAO/D,EAAI+C,EAAK/F,QAAU+F,EAAKc,WAAW7D,KAAO2B,GAAkB,CAC5DoC,EAIHA,GAAU,GAHVC,IACAF,KAIF,MAAMnF,EAAQqB,EACRN,EAAMuE,IACZ,QAAYjG,IAAR0B,EAEF,YADAwE,IAGFJ,IACAK,IACA,MAAMtI,EAAQyH,IACd,QAActF,IAAVnC,EAEF,YADAuI,IAMF,GAAIjE,OAAOkE,UAAUC,eAAexE,KAAKI,EAAQR,KAASqB,EAAYlF,EAAOqE,EAAOR,IAAO,CAGzF,MAAM6E,EAAgBpB,EAAe,CACnCzD,MACA2D,SAAU1E,EAAQ,EAClB6F,SAAUtE,EAAOR,GACjB+E,SAAU5I,SAEUmC,IAAlBuG,IACFrE,EAAOR,GAAO6E,EAElB,MACErE,EAAOR,GAAO7D,CAElB,CAKA,OAJIkH,EAAKc,WAAW7D,KAAO2B,GAqK/B,WACE,MAAM,IAAI/D,YAAY,mDAAmD2F,MAC3E,CAtKMmB,GAEF1E,IACOE,CACT,CACF,CACA,SAASyE,IACP,GAAI5B,EAAKc,WAAW7D,KAAO4B,EAAoB,CAC7C5B,IACA8D,IACA,MAAM/D,EAAQ,GACd,IAAIgE,GAAU,EACd,KAAO/D,EAAI+C,EAAK/F,QAAU+F,EAAKc,WAAW7D,KAAO6B,GAAoB,CAC9DkC,EAGHA,GAAU,EAFVC,IAIF,MAAMnI,EAAQyH,IACdsB,EAAgB/I,GAChBkE,EAAM8E,KAAKhJ,EACb,CAKA,OAJIkH,EAAKc,WAAW7D,KAAO6B,GAiJ/B,WACE,MAAM,IAAIjE,YAAY,2CAA2C2F,MACnE,CAlJMuB,GAEF9E,IACOD,CACT,CACF,CACA,SAASuD,IACPQ,IACA,MAAMjI,EAAQoI,KAkDhB,WACE,MAAMtF,EAAQqB,EACV+C,EAAKc,WAAW7D,KAAOoC,IACzBpC,IACA+E,EAAYpG,IAEd,GAAIoE,EAAKc,WAAW7D,KAAOQ,EACzBR,SACK,GAoHaO,EApHMwC,EAAKc,WAAW7D,GAqHrCO,GAAQ8B,GAAW9B,GAAQE,EAnH9B,IADAT,IACOc,EAAQiC,EAAKc,WAAW7D,KAC7BA,IAiHR,IAAwBO,EA9GpB,GAAIwC,EAAKc,WAAW7D,KAAOuC,EAGzB,IAFAvC,IACA+E,EAAYpG,GACLmC,EAAQiC,EAAKc,WAAW7D,KAC7BA,IAGJ,GAAI+C,EAAKc,WAAW7D,KAAO0C,GAAkBK,EAAKc,WAAW7D,KAAOyC,EAMlE,IALAzC,IACI+C,EAAKc,WAAW7D,KAAOoC,GAAaW,EAAKc,WAAW7D,KAAOmC,GAC7DnC,IAEF+E,EAAYpG,GACLmC,EAAQiC,EAAKc,WAAW7D,KAC7BA,IAGJ,GAAIA,EAAIrB,EACN,OAAOuE,EAAYH,EAAKiC,MAAMrG,EAAOqB,GAEzC,CApFiCiF,IAAkBrB,KAAiBe,KAAgBO,EAAa,QAAQ,IAASA,EAAa,SAAS,IAAUA,EAAa,OAAQ,MAErK,OADApB,IACOjI,CACT,CACA,SAASqJ,EAAaC,EAAMtJ,GAC1B,GAAIkH,EAAKiC,MAAMhF,EAAGA,EAAImF,EAAKnI,UAAYmI,EAErC,OADAnF,GAAKmF,EAAKnI,OACHnB,CAEX,CACA,SAASiI,IACP,MA0JkBvD,EA1JEwC,EAAKc,WAAW7D,MA2JtB8B,GAAavB,IAASwB,GAAexB,IAASyB,GAAWzB,IAAS0B,GA1J9EjC,IAyJN,IAAsBO,CAvJpB,CACA,SAAS0D,IACP,GAAIlB,EAAKc,WAAW7D,KAAOkC,EAAiB,CAC1ClC,IACA,IAAIoF,EAAS,GACb,KAAOpF,EAAI+C,EAAK/F,QAAU+F,EAAKc,WAAW7D,KAAOkC,GAAiB,CAChE,GAAIa,EAAKc,WAAW7D,KAAOyB,EAAe,CACxC,MAAM4D,EAAOtC,EAAK/C,EAAI,GAChBsF,EAAajE,EAAiBgE,QACjBrH,IAAfsH,GACFF,GAAUE,EACVtF,KACkB,MAATqF,EACL/E,EAAMyC,EAAKc,WAAW7D,EAAI,KAAOM,EAAMyC,EAAKc,WAAW7D,EAAI,KAAOM,EAAMyC,EAAKc,WAAW7D,EAAI,KAAOM,EAAMyC,EAAKc,WAAW7D,EAAI,KAC/HoF,GAAU1I,OAAO6I,aAAanJ,OAAOE,SAASyG,EAAKiC,MAAMhF,EAAI,EAAGA,EAAI,GAAI,KACxEA,GAAK,GAELwF,EAA6BxF,GAG/ByF,EAA4BzF,EAEhC,MA6I+BO,EA5IFwC,EAAKc,WAAW7D,KA6IpC,IAAQO,GAAQ,QA5IrB6E,GAAUrC,EAAK/C,GAEf0F,EAAsB3C,EAAK/C,IAG/BA,GACF,CAGA,OAuEJ,WACE,GAAI+C,EAAKc,WAAW7D,KAAOkC,EACzB,MAAM,IAAItE,YAAY,8BAA8B2F,MAExD,CA7EIoC,GACA3F,IACOoF,CACT,CAiIG,IAAgC7E,CAhIrC,CAoCA,SAASyD,IACP,GAAIjB,EAAKc,WAAW7D,KAAOsC,EACzB,MAAM,IAAI1E,YAAY,kCAAkC2F,OAE1DvD,GACF,CACA,SAASmE,IACP,GAAIpB,EAAKc,WAAW7D,KAAOwC,EACzB,MAAM,IAAI5E,YAAY,0CAA0C2F,OAElEvD,GACF,CAMA,SAAS4E,EAAgB/I,GACvB,QAAcmC,IAAVnC,EACF,MAAM,IAAI+B,YAAY,uBAAuB2F,MAEjD,CAMA,SAASwB,EAAYpG,GACnB,IAAKmC,EAAQiC,EAAKc,WAAW7D,IAAK,CAChC,MAAM4F,EAAW7C,EAAKiC,MAAMrG,EAAOqB,GACnC,MAAM,IAAIpC,YAAY,mBAAmBgI,yBAAgCrC,MAC3E,CACF,CAMA,SAASW,IACP,MAAM,IAAItG,YAAY,8BAA8B2F,MACtD,CAcA,SAASmC,EAAsBL,GAC7B,MAAM,IAAIzH,YAAY,sBAAsByH,MAASQ,MACvD,CACA,SAASJ,EAA4B9G,GACnC,MAAMmH,EAAQ/C,EAAKiC,MAAMrG,EAAOA,EAAQ,GACxC,MAAM,IAAIf,YAAY,6BAA6BkI,MAAUD,MAC/D,CACA,SAASzB,IACP,MAAM,IAAIxG,YAAY,mCAAmCiI,MAC3D,CACA,SAASL,EAA6B7G,GACpC,MAAMmH,EAAQ/C,EAAKiC,MAAMrG,EAAOA,EAAQ,GACxC,MAAM,IAAIf,YAAY,8BAA8BkI,MAAUD,MAChE,CAGA,SAASA,IACP,MAAO,eAAe7F,GACxB,CAIA,SAASuD,IACP,MAAO,GAHAvD,EAAI+C,EAAK/F,OAAS,YAAY+F,EAAK/C,MAAQ,8BAG/B6F,KACrB,CACF,EEhHAzK,EAAAmE,oBAAAA,EAAAnE,EAAA2K,qBJ/JO,SAA8BlK,GACnC,OAAOD,EAAUC,GAASwD,OAAOxD,GAASO,OAAOI,WAAWX,EAC9D,EI6JAT,EAAA4K,WDjKO,SAAoBC,EAAMpK,GAC/B,MAAwB,iBAAVA,GAAsB8G,EAAa5G,KAAKF,GAAS,IAAIqK,KAAKrK,GAASA,CACnF,EC+JAT,EAAAsC,YAAAA,EAAAtC,EAAA+K,UAhIO,SAASA,EAAUtK,EAAOuK,EAAUC,EAAOC,GAChD,MAAMC,EAuHR,SAAsBF,GACpB,GAAqB,iBAAVA,EACT,MAAO,IAAIG,OAAOH,GAEpB,GAAqB,iBAAVA,GAAgC,KAAVA,EAC/B,OAAOA,EAET,MACF,CA/HwBI,CAAaJ,GAInC,OAAOK,EAHmC,mBAAbN,EAA0BA,EAAStG,KAAK,CACnE,GAAIjE,GACH,GAAIA,GAASA,EACqB,IAKrC,SAAS6K,EAAe7K,EAAO8K,GAC7B,GAAI/G,MAAMC,QAAQyG,GAAqB,CACrC,MAAMM,EAAcN,EAAmBO,MAAK5F,GAAQA,EAAKlF,KAAKF,KAC9D,GAAI+K,EAAa,CACf,MAAME,EAAMF,EAAYT,UAAUtK,GAClC,GAAmB,iBAARiL,IAAqB9K,EAAS8K,GACvC,MAAM,IAAI5H,MAAM,0GAA0G4H,MAE5H,OAAOA,CACT,CACF,CAGA,MAAqB,kBAAVjL,GAAwC,iBAAVA,GAAuC,iBAAVA,GAAgC,OAAVA,GAAkBA,aAAiBqK,MAAQrK,aAAiBkL,SAAWlL,aAAiBO,QAAUP,aAAiBa,OACtMsK,KAAKb,UAAUtK,GAKpBA,GAAOmD,kBAKU,iBAAVnD,EAJFA,EAAMyD,WASXM,MAAMC,QAAQhE,GAcpB,SAAwBkE,EAAO4G,GAC7B,GAAqB,IAAjB5G,EAAM/C,OACR,MAAO,KAET,MAAMiK,EAAcV,EAAgBI,EAASJ,OAAgBvI,EAC7D,IAAI8I,EAAMP,EAAgB,MAAQ,IAClC,IAAK,IAAIvG,EAAI,EAAGA,EAAID,EAAM/C,OAAQgD,IAAK,CACrC,MAAMiB,EAA2B,mBAAbmF,EAA0BA,EAAStG,KAAKC,EAAOrD,OAAOsD,GAAID,EAAMC,IAAMD,EAAMC,GAC5FuG,IACFO,GAAOG,GAGPH,QADkB,IAAT7F,GAAwC,mBAATA,EACjCyF,EAAezF,EAAMgG,GAErB,OAELjH,EAAID,EAAM/C,OAAS,IACrB8J,GAAOP,EAAgB,MAAQ,IAEnC,CAEA,OADAO,GAAOP,EAAgB,KAAKI,KAAY,IACjCG,CACT,CAnCWI,CAAerL,EAAO8K,GAI3B9K,GAA0B,iBAAVA,EAoCtB,SAAyBqE,EAAQyG,GAC/B,GAA6B,mBAAlBzG,EAAOiH,OAChB,OAAOhB,EAAUjG,EAAOiH,SAAUf,EAAUC,OAAOrI,GAErD,MAAMoC,EAAOR,MAAMC,QAAQuG,GAAYA,EAASgB,IAAI1K,QAAUyD,OAAOC,KAAKF,GAC1E,GAAoB,IAAhBE,EAAKpD,OACP,MAAO,KAET,MAAMiK,EAAcV,EAAgBI,EAASJ,OAAgBvI,EAC7D,IAAIqJ,GAAQ,EACRP,EAAMP,EAAgB,MAAQ,IAClC,IAAK,MAAM7G,KAAOU,EAAM,CACtB,MAAMvE,EAA4B,mBAAbuK,EAA0BA,EAAStG,KAAKI,EAAQR,EAAKQ,EAAOR,IAAQQ,EAAOR,GAChG,GAAI4H,EAAgB5H,EAAK7D,GAAQ,CAC3BwL,EACFA,GAAQ,EAERP,GAAOP,EAAgB,MAAQ,IAEjC,MAAMgB,EAASP,KAAKb,UAAUzG,GAC9BoH,GAAOP,EAAgB,GAAGU,EAAcM,MAAa,GAAGA,KACxDT,GAAOJ,EAAe7K,EAAOoL,EAC/B,CACF,CAEA,OADAH,GAAOP,EAAgB,KAAKI,KAAY,IACjCG,CACT,CA7DWU,CAAgB3L,EAAO8K,QADhC,CAIF,CA+DA,SAASW,EAAgBrB,EAAMpK,GAC7B,YAAwB,IAAVA,GAA0C,mBAAVA,GAAyC,iBAAVA,CAC/E,CACF,EAcAT,EAAAqM,iBL/FO,SAA0B5L,GAE/B,GD6FK,SAAgCA,GACrC,MAAM8C,MACJA,EAAKC,IACLA,GACEC,EAAyBhD,GACvBoC,EAAMpC,EAAMqC,QAAQ,KAC1B,OAAY,IAARD,GAAcA,EAAMU,GAASV,EAAMW,EAC9BA,EAAMD,EAERC,EAAMD,EAAQ,CACvB,CCvGM+I,CAAuBhL,OAAOb,IADhB,GAEhB,MAAM,IAAIqD,MAAM,0GAA0GrD,MAE5H,GAAIO,OAAOuL,MAAM9L,GACf,MAAM,IAAIqD,MAAM,uBAElB,IAAK9C,OAAOkB,SAASzB,GACnB,MAAM,IAAIqD,MAAM,mBAAmBrD,KAErC,OAAO,IAAIkD,EAAerC,OAAOb,GACnC,EKmFAT,EAAAwM,oBN7EO,SAA6B/L,EAAOM,GACzC,MAAM0L,EAASzL,OAAOI,WAAWX,GAC3BuD,EAAehC,EAAsBvB,GAC3C,IAAuB,IAAnBM,GAAQW,OAAkBsC,GAAgBA,IAAiBjC,EAAmBK,eAAiB4B,EAAc,CAC/G,MAAM0I,EAAmB1I,GAAchB,QAAQ,QAAS,IACxD,MAAM,IAAIc,MAAM,+CAA+CrD,YAAgBiM,gBAA+BD,IAChH,CACA,OAAOA,CACT,CMqEA"}